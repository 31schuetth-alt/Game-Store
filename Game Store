<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
 <title>Jumping Doodler</title>
 <style>
 body {
 margin: 0;
 padding: 0;
 overflow: hidden;
 font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif;
 background-color: #fcfcf0;
 /* Graph paper effect */
 background-image: 
 linear-gradient(rgba(200, 200, 200, 0.3) 1px, transparent 1px),
 linear-gradient(90deg, rgba(200, 200, 200, 0.3) 1px, transparent 1px);
 background-size: 20px 20px;
 touch-action: none; /* Prevent browser zooming/scrolling */
 display: flex;
 justify-content: center;
 align-items: center;
 height: 100vh;
 }

 #game-container {
 position: relative;
 width: 100%;
 max-width: 450px;
 height: 100%;
 max-height: 800px;
 box-shadow: 0 0 20px rgba(0,0,0,0.1);
 background-color: rgba(255, 255, 255, 0.5); 
 }

 canvas {
 display: block;
 width: 100%;
 height: 100%;
 }

 #score-display {
 position: absolute;
 top: 10px;
 left: 20px;
 font-size: 24px;
 font-weight: bold;
 color: #333;
 pointer-events: none;
 }

 #game-over-screen {
 position: absolute;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background: rgba(255, 255, 255, 0.85);
 display: none;
 flex-direction: column;
 justify-content: center;
 align-items: center;
 text-align: center;
 }

 #game-over-screen h1 {
 color: #d32f2f;
 font-size: 40px;
 margin: 0 0 10px 0;
 }

 #final-score {
 font-size: 24px;
 color: #333;
 margin-bottom: 30px;
 }

 button {
 padding: 15px 40px;
 font-size: 20px;
 font-family: inherit;
 background-color: #66bb6a;
 color: white;
 border: none;
 border-radius: 8px;
 cursor: pointer;
 box-shadow: 0 4px 0 #388e3c;
 transition: transform 0.1s;
 }

 button:active {
 transform: translateY(4px);
 box-shadow: none;
 }

 .controls-hint {
 position: absolute;
 bottom: 20px;
 width: 100%;
 text-align: center;
 color: #888;
 font-size: 14px;
 pointer-events: none;
 opacity: 0.7;
 }
 </style>
</head>
<body>

<div id="game-container">
 <div id="score-display">0</div>
 <canvas id="game"></canvas>
 
 <div id="game-over-screen">
 <h1>Game Over!</h1>
 <p>Score: <span id="final-score">0</span></p>
 <button onclick="resetGame()">Play Again</button>
 </div>

 <div class="controls-hint" id="controls-hint">
 Use Arrow Keys or Tap Left/Right to Move
 </div>
</div>

<script>
 const canvas = document.getElementById('game');
 const ctx = canvas.getContext('2d');
 const scoreDisplay = document.getElementById('score-display');
 const gameOverScreen = document.getElementById('game-over-screen');
 const finalScoreSpan = document.getElementById('final-score');
 const controlsHint = document.getElementById('controls-hint');

 // Game Variables
 let width, height;
 let score = 0;
 let isGameOver = false;
 let platforms = [];
 let keys = { left: false, right: false };
 let animationId;
 
 // Physics Constants
 const GRAVITY = 0.4;
 const JUMP_FORCE = -12;
 const SPRING_FORCE = -22; // Super jump!
 const MOVE_SPEED = 6;
 const PLATFORM_WIDTH = 60;
 const PLATFORM_HEIGHT = 15;
 
 // Player Object
 const doodler = {
 x: 0,
 y: 0,
 width: 40,
 height: 40,
 vx: 0,
 vy: 0,
 facingRight: true,
 
 draw: function() {
 ctx.save();
 ctx.translate(this.x, this.y);
 
 if (!this.facingRight) {
 ctx.scale(-1, 1);
 }

 // Body (Green)
 ctx.fillStyle = '#66bb6a'; 
 ctx.strokeStyle = '#2e7d32';
 ctx.lineWidth = 2;
 
 // Main body shape
 ctx.beginPath();
 ctx.rect(-15, -20, 30, 40); 
 ctx.arc(0, -20, 15, Math.PI, 0); 
 ctx.arc(0, 20, 15, 0, Math.PI); 
 ctx.fill();
 ctx.stroke();

 // Legs
 ctx.beginPath();
 ctx.moveTo(-10, 30);
 ctx.lineTo(-10, 40);
 ctx.moveTo(10, 30);
 ctx.lineTo(10, 40);
 ctx.stroke();

 // Snout
 ctx.beginPath();
 ctx.rect(10, -15, 10, 15);
 ctx.arc(20, -7.5, 7.5, -Math.PI/2, Math.PI/2);
 ctx.fill();
 ctx.stroke();

 // Eye
 ctx.fillStyle = 'white';
 ctx.beginPath();
 ctx.arc(5, -10, 5, 0, Math.PI*2);
 ctx.fill();
 ctx.stroke();
 
 // Pupil
 ctx.fillStyle = 'black';
 ctx.beginPath();
 ctx.arc(7, -10, 2, 0, Math.PI*2);
 ctx.fill();

 // Backpack (simple)
 ctx.fillStyle = '#4caf50';
 ctx.fillRect(-20, -10, 5, 20);

 ctx.restore();
 }
 };

 function resize() {
 const container = document.getElementById('game-container');
 width = container.offsetWidth;
 height = container.offsetHeight;
 canvas.width = width;
 canvas.height = height;
 }

 function generatePlatform(y) {
 const x = Math.random() * (width - PLATFORM_WIDTH);
 
 let type = 'normal';
 let speed = 0;
 let hasSpring = false;

 // Difficulty progression
 // Moving platforms after 500 points
 if (score > 500 && Math.random() < 0.2) {
 type = 'moving';
 speed = 2 + Math.random() * 2;
 }
 // Breakable platforms after 1000 points
 else if (score > 1000 && Math.random() < 0.15) {
 type = 'breakable';
 }

 // Add Springs (10% chance on non-breakable platforms)
 if (type !== 'breakable' && Math.random() < 0.1) {
 hasSpring = true;
 }

 platforms.push({ 
 x, 
 y, 
 type, 
 speed, 
 direction: Math.random() > 0.5 ? 1 : -1,
 hasSpring,
 isBroken: false,
 springAnim: 0 // 0 = compressed, >0 = extending
 });
 }

 function initPlatforms() {
 platforms = [];
 platforms.push({ x: width/2 - PLATFORM_WIDTH/2, y: height - 100, type: 'normal', speed: 0, hasSpring: false });
 
 for (let y = height - 200; y > 0; y -= 80) { 
 generatePlatform(y);
 }
 }

 function resetGame() {
 if (animationId) cancelAnimationFrame(animationId);
 resize();
 isGameOver = false;
 score = 0;
 scoreDisplay.innerText = "0";
 gameOverScreen.style.display = 'none';
 controlsHint.style.display = 'block';

 doodler.x = width / 2;
 doodler.y = height - 200;
 doodler.vx = 0;
 doodler.vy = JUMP_FORCE;
 doodler.facingRight = true;

 initPlatforms();
 gameLoop();
 }

 // Input Handling
 window.addEventListener('keydown', (e) => {
 if (e.code === 'ArrowLeft') keys.left = true;
 if (e.code === 'ArrowRight') keys.right = true;
 });

 window.addEventListener('keyup', (e) => {
 if (e.code === 'ArrowLeft') keys.left = false;
 if (e.code === 'ArrowRight') keys.right = false;
 });

 canvas.addEventListener('touchstart', (e) => {
 e.preventDefault();
 controlsHint.style.display = 'none';
 const touchX = e.touches[0].clientX;
 const rect = canvas.getBoundingClientRect();
 const x = touchX - rect.left;
 if (x < width / 2) { keys.left = true; keys.right = false; } 
 else { keys.right = true; keys.left = false; }
 }, {passive: false});

 canvas.addEventListener('touchend', (e) => {
 e.preventDefault();
 keys.left = false;
 keys.right = false;
 });

 function update() {
 if (isGameOver) return;

 // Player Movement
 if (keys.left) {
 doodler.vx = -MOVE_SPEED;
 doodler.facingRight = false;
 } else if (keys.right) {
 doodler.vx = MOVE_SPEED;
 doodler.facingRight = true;
 } else {
 doodler.vx *= 0.8; 
 }

 doodler.x += doodler.vx;

 // Screen Wrapping
 if (doodler.x < -doodler.width/2) {
 doodler.x = width + doodler.width/2;
 } else if (doodler.x > width + doodler.width/2) {
 doodler.x = -doodler.width/2;
 }

 doodler.vy += GRAVITY;
 doodler.y += doodler.vy;

 // Moving Platforms Logic
 platforms.forEach(p => {
 if (p.type === 'moving') {
 p.x += p.speed * p.direction;
 if (p.x <= 0 || p.x + PLATFORM_WIDTH >= width) {
 p.direction *= -1;
 }
 }
 // Animate breaking
 if (p.isBroken) {
 p.y += 5; // Fall down
 }
 });

 // Camera / Scroll Logic
 const threshold = height * 0.4;
 if (doodler.y < threshold) {
 const diff = threshold - doodler.y;
 doodler.y = threshold;
 
 platforms.forEach(p => p.y += diff);
 score += Math.floor(diff / 2); 
 scoreDisplay.innerText = score;

 platforms = platforms.filter(p => p.y < height);

 const lastPlatformY = platforms.length > 0 ? Math.min(...platforms.map(p => p.y)) : 0;
 if (lastPlatformY > 80) { 
 generatePlatform(lastPlatformY - 80 - (Math.random() * 40));
 }
 }

 // Collision Detection
 if (doodler.vy > 0) {
 platforms.forEach(p => {
 // Ignore if platform is already broken and falling
 if (p.isBroken) return;

 if (
 doodler.x + 15 > p.x && 
 doodler.x - 15 < p.x + PLATFORM_WIDTH &&
 doodler.y + 25 > p.y && 
 doodler.y + 25 < p.y + PLATFORM_HEIGHT + 10
 ) {
 if (p.type === 'breakable') {
 p.isBroken = true;
 // Play break sound if we had one
 } else {
 // Check for Spring
 if (p.hasSpring && 
 doodler.x > p.x + 10 && // Approximate spring location
 doodler.x < p.x + PLATFORM_WIDTH - 10) {
 doodler.vy = SPRING_FORCE;
 p.springAnim = 10; // Trigger anim
 } else {
 doodler.vy = JUMP_FORCE; 
 }
 }
 }
 });
 }

 if (doodler.y > height) {
 isGameOver = true;
 finalScoreSpan.innerText = score;
 gameOverScreen.style.display = 'flex';
 }
 }

 function draw() {
 ctx.clearRect(0, 0, width, height);

 platforms.forEach(p => {
 
 // Set Color based on Type
 if (p.type === 'normal') {
 ctx.fillStyle = '#66bb6a'; // Green
 ctx.strokeStyle = '#388e3c';
 } else if (p.type === 'moving') {
 ctx.fillStyle = '#42a5f5'; // Blue
 ctx.strokeStyle = '#1e88e5';
 } else if (p.type === 'breakable') {
 ctx.fillStyle = '#8d6e63'; // Brown
 ctx.strokeStyle = '#5d4037';
 
 if (p.isBroken) {
 // Draw broken pieces
 ctx.save();
 ctx.translate(p.x, p.y);
 ctx.fillStyle = '#8d6e63';
 ctx.fillRect(0, 0, PLATFORM_WIDTH/2 - 2, PLATFORM_HEIGHT);
 ctx.fillRect(PLATFORM_WIDTH/2 + 2, 5, PLATFORM_WIDTH/2 - 2, PLATFORM_HEIGHT); // Offset right piece
 ctx.restore();
 return; // Skip normal draw
 }
 }

 // Draw Platform Body
 const r = 5; 
 ctx.lineWidth = 2;
 ctx.beginPath();
 ctx.moveTo(p.x + r, p.y);
 ctx.lineTo(p.x + PLATFORM_WIDTH - r, p.y);
 ctx.quadraticCurveTo(p.x + PLATFORM_WIDTH, p.y, p.x + PLATFORM_WIDTH, p.y + r);
 ctx.lineTo(p.x + PLATFORM_WIDTH, p.y + PLATFORM_HEIGHT - r);
 ctx.quadraticCurveTo(p.x + PLATFORM_WIDTH, p.y + PLATFORM_HEIGHT, p.x + PLATFORM_WIDTH - r, p.y + PLATFORM_HEIGHT);
 ctx.lineTo(p.x + r, p.y + PLATFORM_HEIGHT);
 ctx.quadraticCurveTo(p.x, p.y + PLATFORM_HEIGHT, p.x, p.y + PLATFORM_HEIGHT - r);
 ctx.lineTo(p.x, p.y + r);
 ctx.quadraticCurveTo(p.x, p.y, p.x + r, p.y);
 ctx.fill();
 ctx.stroke();
 
 // Draw Inner highlight (for pseudo-3D look)
 ctx.fillStyle = 'rgba(255,255,255,0.2)';
 ctx.fill();

 // Draw Spring if present
 if (p.hasSpring) {
 const springX = p.x + PLATFORM_WIDTH/2 - 10;
 const springY = p.y - 10;
 
 ctx.fillStyle = '#bdbdbd'; // Silver
 ctx.strokeStyle = '#757575';
 
 if (p.springAnim > 0) {
 // Extended spring
 ctx.beginPath();
 ctx.rect(springX, springY - 15, 20, 25);
 ctx.fill();
 ctx.stroke();
 p.springAnim--;
 } else {
 // Coiled spring
 ctx.beginPath();
 ctx.rect(springX, springY, 20, 10);
 ctx.fill();
 ctx.stroke();
 
 // Coils
 ctx.beginPath();
 ctx.moveTo(springX, springY + 3);
 ctx.lineTo(springX + 20, springY + 3);
 ctx.moveTo(springX, springY + 7);
 ctx.lineTo(springX + 20, springY + 7);
 ctx.stroke();
 }
 }
 });

 doodler.draw();
 }

 function gameLoop() {
 update();
 draw();
 if (!isGameOver) {
 animationId = requestAnimationFrame(gameLoop);
 }
 }

 window.addEventListener('resize', resize);
 window.onload = resetGame;

</script>
</body>
</html>
